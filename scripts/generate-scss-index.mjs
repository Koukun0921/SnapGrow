import fs from "node:fs";
import path from "node:path";

const STYLES_ROOT = path.resolve("src/sass");
const HEADER = `// ========================================================================== 
// ⚠️ DO NOT EDIT THIS FILE
// This file is auto-generated by scripts/generate-scss-index.mjs
// ==========================================================================
`;

const results = new Map();

async function main() {
  console.log("Generating SCSS index files...");

  const directories = collectDirectories(STYLES_ROOT).sort(
    (a, b) => depth(b) - depth(a)
  );
  console.log(`Found ${directories.length} directories under src/sass`);

  for (const dir of directories) {
    // ルートディレクトリ（src/sass）はスキップ
    if (dir === STYLES_ROOT) {
      continue;
    }
    console.log(`Processing ${path.relative(STYLES_ROOT, dir) || "."}`);
    const hasContent = buildIndex(dir, results);
    results.set(dir, hasContent);
    console.log(
      `Finished ${path.relative(STYLES_ROOT, dir) || "."} (has content: ${
        hasContent ? "yes" : "no"
      })`
    );
  }

  console.log("SCSS index generation completed.");
}

try {
  await main();
} catch (error) {
  console.error("Failed to generate SCSS indexes:", error);
  process.exitCode = 1;
}

function depth(dirPath) {
  return dirPath.split(path.sep).length;
}

function collectDirectories(root) {
  const dirs = [root]; // ルートディレクトリも含める

  function walk(current) {
    try {
      const entries = fs.readdirSync(current, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isDirectory()) {
          const absPath = path.join(current, entry.name);
          dirs.push(absPath);
          walk(absPath);
        }
      }
    } catch (error) {
      console.error(`Error reading directory ${current}:`, error.message);
    }
  }

  walk(root);
  return dirs;
}

function buildIndex(dir, results) {
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    const files = entries
      .filter(
        (entry) =>
          entry.isFile() &&
          entry.name.endsWith(".scss") &&
          entry.name !== "_index.scss"
      )
      .map((entry) => entry.name)
      .sort((a, b) => a.localeCompare(b));

    const subdirs = entries
      .filter((entry) => entry.isDirectory())
      .map((entry) => entry.name)
      .sort((a, b) => a.localeCompare(b));

    const statements = [];

    for (const file of files) {
      const base = file.replace(/^_/, "").replace(/\.s[ac]ss$/i, "");
      statements.push(`@forward "./${base}";`);
    }

    for (const subdir of subdirs) {
      const absPath = path.join(dir, subdir);
      if (results.get(absPath)) {
        statements.push(`@forward "./${subdir}/index";`);
      }
    }

    const indexPath = path.join(dir, "_index.scss");

    if (!statements.length) {
      if (fs.existsSync(indexPath)) {
        fs.rmSync(indexPath);
        console.log(
          `Removed empty index: ${path.relative(process.cwd(), indexPath)}`
        );
      }
      return false;
    }

    const content = `${HEADER}\n${statements.join("\n")}\n`;

    if (
      !fs.existsSync(indexPath) ||
      fs.readFileSync(indexPath, "utf8") !== content
    ) {
      fs.writeFileSync(indexPath, content);
      console.log(
        `Generated index: ${path.relative(process.cwd(), indexPath)}`
      );
    }

    return true;
  } catch (error) {
    console.error(
      `Error processing ${path.relative(process.cwd(), dir)}:`,
      error.message
    );
    return false;
  }
}
